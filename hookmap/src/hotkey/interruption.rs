use std::sync::atomic::AtomicBool;
use std::sync::mpsc::Receiver;
use std::sync::{Arc, Mutex};

use hookmap_core::button::{Button, ButtonAction};
use hookmap_core::event::{ButtonEvent, NativeEventOperation};

use crate::runtime::interruption::{InterruptionKind, InterruptionStorage};

use super::args::ButtonArgs;

#[derive(Debug)]
pub struct Filter {
    targets: ButtonArgs,
    action: Option<ButtonAction>,
    injected: Option<bool>,
}

impl Filter {
    /// Creates a new instance of [`InterruptionConfig`] with default values.
    ///
    /// # Example
    ///
    /// ```
    /// use hookmap::prelude::*;
    /// use Button::*;
    ///
    /// let hotkey = Hotkey::new();
    /// let i = hotkey.interruption();
    /// i.spawn(|mut int| {
    ///     let filter = Filter::new()
    ///         .targets(each![LeftArrow, DownArrow, UpArrow, RightArrow])
    ///         .action(ButtonAction::Press)
    ///         .injected(false);
    ///
    ///     int.set_filter(filter);
    /// });
    /// ```
    ///
    pub fn new() -> Self {
        Self::default()
    }

    /// Filter events according to which button they are generated from.
    /// Default is any key.
    ///
    /// See [`ButtonEvent::target`].
    ///
    /// # Example
    ///
    /// ```
    /// use hookmap::prelude::*;
    /// use Button::*;
    ///
    /// Filter::new().targets(not![A, B, C]);
    /// ```
    ///
    /// [`ButtonEvent::target`]: crate::device::ButtonEvent::target
    ///
    pub fn targets(mut self, targets: impl Into<ButtonArgs>) -> Self {
        self.targets = targets.into();
        self
    }

    /// Filters events by whether the button is pressed or released.
    /// Default is both.
    ///
    /// See [`ButtonEvent::injected`].
    ///
    /// # Example
    ///
    /// ```
    /// use hookmap::prelude::*;
    ///
    /// Filter::new().action(ButtonAction::Press);
    /// ```
    ///
    /// [`ButtonEvent::action`]: crate::device::ButtonEvent::action
    ///
    pub fn action(mut self, action: ButtonAction) -> Self {
        self.action = Some(action);
        self
    }

    /// Filters events by whether the event is generated by the program.
    /// Default is both.
    ///
    /// See [`ButtonEvent::injected`].
    ///
    /// # Example
    ///
    /// ```
    /// use hookmap::prelude::*;
    ///
    /// let filter = Filter::new().injected(false);
    /// ```
    ///
    /// [`ButtonEvent::injected`]: crate::device::ButtonEvent::injected
    ///
    pub fn injected(mut self, injected: bool) -> Self {
        self.injected = Some(injected);
        self
    }
}

impl Default for Filter {
    fn default() -> Self {
        Self {
            targets: ButtonArgs::Not(Arc::default()),
            action: Default::default(),
            injected: Default::default(),
        }
    }
}

impl Filter {
    #[inline]
    fn filter_target(&self, target: Button) -> bool {
        match &self.targets {
            ButtonArgs::Each(targets) => targets.contains(&target),
            ButtonArgs::Not(targets) => !targets.contains(&target),
        }
    }

    #[inline]
    fn filter_action(&self, action: ButtonAction) -> bool {
        match self.action {
            Some(a) => a == action,
            None => true,
        }
    }

    #[inline]
    fn filter_injected(&self, injected: bool) -> bool {
        match self.injected {
            Some(i) => i == injected,
            None => true,
        }
    }

    fn filter(&self, event: &ButtonEvent) -> bool {
        self.filter_injected(event.injected)
            && self.filter_action(event.action)
            && self.filter_target(event.target)
    }
}

pub struct Iter<'a> {
    rx: &'a InterruptionReceiver,
    method: fn(&InterruptionReceiver) -> ButtonEvent,
}

impl<'a> Iter<'a> {
    fn new(rx: &'a InterruptionReceiver, method: fn(&InterruptionReceiver) -> ButtonEvent) -> Self {
        Self { rx, method }
    }
}

impl<'a> std::fmt::Debug for Iter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Iter")
            .field("rx", &self.rx)
            .finish_non_exhaustive()
    }
}

impl<'a> Iterator for Iter<'a> {
    type Item = ButtonEvent;

    fn next(&mut self) -> Option<Self::Item> {
        Some((self.method)(self.rx))
    }
}

#[derive(Debug)]
struct Inner {
    kind: InterruptionKind,
    native: NativeEventOperation,
    active: Arc<AtomicBool>,
    rx: Receiver<ButtonEvent>,
}

impl Inner {
    fn new(
        kind: InterruptionKind,
        native: NativeEventOperation,
        storage: &mut InterruptionStorage,
    ) -> Self {
        let (active, rx) = storage.register(kind, native);
        Self {
            kind,
            native,
            active,
            rx,
        }
    }
}

#[derive(Debug)]
pub struct InterruptionReceiver {
    storage: Arc<Mutex<InterruptionStorage>>,
    inner: Mutex<Option<Inner>>,
    filter: Filter,
    native: NativeEventOperation,
}

impl InterruptionReceiver {
    fn new(storage: Arc<Mutex<InterruptionStorage>>) -> Self {
        Self {
            storage,
            inner: Mutex::default(),
            filter: Filter::default(),
            native: NativeEventOperation::Dispatch,
        }
    }

    fn recv(&self, kind: InterruptionKind, native: NativeEventOperation) -> ButtonEvent {
        let mut inner = self.inner.lock().unwrap();

        let inner = match &*inner {
            Some(inner) if inner.kind == kind || inner.native == native => inner,
            _ => inner.insert(Inner::new(kind, native, &mut *self.storage.lock().unwrap())),
        };

        inner
            .rx
            .iter()
            .find(|event| self.filter.filter(event))
            .unwrap()
    }

    pub fn get(&self) -> ButtonEvent {
        self.recv(InterruptionKind::HookShare, self.native)
    }

    pub fn get_raw(&self) -> ButtonEvent {
        self.recv(InterruptionKind::RawShare, self.native)
    }

    pub fn get_block(&self) -> ButtonEvent {
        self.recv(InterruptionKind::HookBlock, self.native)
    }

    pub fn get_raw_block(&self) -> ButtonEvent {
        self.recv(InterruptionKind::RawBlock, self.native)
    }

    pub fn iter(&self) -> Iter {
        Iter::new(self, Self::get)
    }

    pub fn iter_raw(&self) -> Iter {
        Iter::new(self, Self::get_raw)
    }

    pub fn iter_block(&self) -> Iter {
        Iter::new(self, Self::get_block)
    }

    pub fn iter_raw_block(&self) -> Iter {
        Iter::new(self, Self::get_raw_block)
    }
}

#[derive(Debug)]
pub struct Interruption {
    storage: Arc<Mutex<InterruptionStorage>>,
}

impl Interruption {
    pub(crate) fn new(storage: Arc<Mutex<InterruptionStorage>>) -> Self {
        Self { storage }
    }

    pub fn spawn<F>(&self, f: F)
    where
        F: FnOnce(InterruptionReceiver) + Send + 'static,
    {
        let storage = Arc::clone(&self.storage);
        std::thread::spawn(move || {
            f(InterruptionReceiver::new(storage));
        });
    }
}
